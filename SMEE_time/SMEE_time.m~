function SMEE_time(run_name, noiseType, model, catalogue, wv, ra, dec, psi, trigtime,detno, numPCs, seed, typeofscaling, scaling, realnoise,doPlot,doSky,doDistance, doTimeshift)
%nested sampling code with coherent analysis of multiple detectors,
%coloured noise, and the possibility of a time shift between the loaction
%of signal in the data and the reconstruction of it

% a nested sampling code used to compare two supernova models. It does this
% by calculated a Bayes Factor for a waveform using the equation
% y=V*beta+epsilon, over data just containing noise.
% V is matrix containing the principal components and
% epsilon is a gaussian noise vector. beta is a vector of principal
% component coefficients and is what the nested sample is set up to find.
% This is repeated for 2 sets of principal components and so a Bayes Factor
% comparing the two models can be calculated.

% This is set up to compare waveforms from Dimmelmeier et al. 2008 and
% Abdikamalov et al. 2010 but can be adapted to use whatever catalogue you
% want. To create a set of principal components for a catalogue use
% pca_sne_waveform1.m after first using resample.m to resample the
% waveforms in the catalogue to a rate of 4096 Hz.

% This code uses 6 PC's but can be reduced/increased to increase
% speed/accuracy

% Have included functions to the antenna response factor for
% detectors of user's choosing.

% Arguments:
%           run_name -- name of folder in which the store results
%           noiseType -- 'aligo', 'ligo3'. 
%           model -- model used to reconstruct waveform
%               = 'Abd', 'Dim'
%           catalogue -- catalogue from which to draw waveform
%               = 'Abd', 'Dim'
%           wv -- specific waveform to use
%               = 1...106 for Abdikamalov
%               = 1...136 for Dimmelmeier
%           ra -- right ascension of source, in radians
%           dec -- declination of source
%           psi -- polarisation angle in radians
%           trigtime-- GPS time of the trigger to analyse
%           detector-- A cell containing a string, it specifies the 
%           detector sites on to which to project the signal, and must be 
%           one of the values recognized by the function LoadDetectorData.
%           numPCs -- no. of principal components to use when
%           reconstructing the waveform; default: 6
%               = 1...10 when model ~= Ott
%               = 1...6 when model == Ott
%           typeofscaling -- type of scaling to be applied to waveform 
%               = 'SNR'  for SNR scaling
%               = 'd' 'dist' 'dis' 'distance'  for Distance scaling
%               = all else  for no scaling (default option)
%               note: case insensitive
%           scaling -- SNR scaling: waveform is scaled to have this SNR;
%                      Distance scaling: waveform is scaled to be at this 
%                      distance, in kpc; default in each case: no scaling
%           seed -- random seed used to control noise generation etc.
%           doDistance -- flag to use distance as additional parameter;
%           default: not on
%           doTimeshift -- flag to use bounce location in time-series as
%           additional parameter; default: not on
%           doPlot -- flag to plot convergence of algorithm; default: not
%           on

%Normalise inputs
if (ischar(wv)), wv=str2num(wv); end
if (ischar(seed)), seed=str2num(seed); end
if (ischar(ra)), ra=str2num(ra); end
if (ischar(dec)), dec=str2num(dec); end
if (ischar(psi)), psi=str2num(psi); end
if (ischar(trigtime)), trigtime=str2num(trigtime); end
if (~exist('typeofscaling','var')), typeofscaling='none'; end
if (~exist('scaling','var')), scaling='';
elseif (ischar(scaling)), scaling=str2num(scaling); end
if (~exist('detno','var')), detno=1;
elseif (ischar(detno)), detno=floor(abs(str2num(detno))); end
if detno < 1 || mod(detno,1)
    fprintf(1,'Error: detno must be positive integer\n');
    detno = floor(abs(detno)+1);
    fprintf(1,'detno changed to %i\n',detno);
end
if (~exist('numPCs','var')), numPCs=6;
elseif (ischar(numPCs)), numPCs=str2num(numPCs); end
if numPCs < 1 || mod(numPCs,1)
    fprintf(1,'Error: numPCs must be positive integer\n');
    numPCs = floor(abs(numPCs)+1);
    fprintf(1,'numPCs changed to %i\n',numPCs);
end
if (~exist('realnoise','var')), realnoise=0;
elseif (ischar(realnoise)), realnoise=str2num(realnoise); end

if (~exist('doSky','var')), doSky=0;
elseif (ischar(doSky)), doTimeshift=str2num(doSky); end
if doSky > 0, doSky = 1; else doSky = 0; end
if (~exist('doTimeshift','var')), doTimeshift=0;
elseif (ischar(doTimeshift)), doTimeshift=str2num(doTimeshift); end
if doTimeshift > 0, doTimeshift = 1; else doTimeshift = 0; end
if (~exist('doDistance','var')), doDistance=0;
elseif (ischar(doDistance)), doDistance=str2num(doDistance); end
if doDistance > 0, doDistance = 1; else doDistance = 0; end
if (~exist('doPlot','var')), doPlot=0;
elseif (ischar(doPlot)), doPlot=str2num(doPlot); end

%noise curve to use
if strcmpi(noiseType, 'ligo3')
   %noise_curve = 'LIGO3_PSD.txt';
   noise_curve='ET_B.txt';
elseif strcmpi(noiseType, 'aligo')
   noise_curve = 'ZERO_DET_high_P.txt';
end

display(sprintf('SMEE: %s %s %s %i', noise_curve, model, catalogue, wv));

reset(RandStream.getDefaultStream,seed);
tic

clearvars -except run_name catalogue wv model seed typeofscaling scaling ...
    numPCs doTimeshift doDistance doPlot noise_curve ra dec psi trigtime detno doSky realnoise

%names of detectors
detector = {'H1','L1','V1','I1','H1'};%LIGO H1 and L1



% assigns the noise to be used with each detector
for cntdet=1:detno
    if strcmp(detector(cntdet), 'L1');
        noisecurve{cntdet}= 'ZERO_DET_high_P.txt';
    
    elseif strcmp(detector(cntdet), 'H1');
        noisecurve{cntdet}= 'ZERO_DET_high_P.txt';
        %noisecurve{cntdet}= 'ET_B.txt';  
        
     elseif strcmp(detector(cntdet), 'I1');
        noisecurve{cntdet}= 'ZERO_DET_high_P.txt';
        load IndiaD.txt
        detector{cntdet}=IndiaD;
        %noisecurve{cntdet}= 'ET_B.txt';     
    elseif strcmp(detector(cntdet), 'V1');
        noisecurve{cntdet}= 'AdvVirgo.txt'; 
    elseif strcmp(detector(cntdet), 'E1');
        noisecurve{cntdet}= 'ET_B.txt'; 
    elseif strcmp(detector(cntdet), 'J1');
        noisecurve{cntdet}= 'KAGRAcurve.dat' ;  
        load KAGRAD.txt
        detector{cntdet}=KAGRAD;
    end
end
%detno=numdetector;
evnoise = zeros(detno,1);
maxits = 15000;% max no. of iterations expected from nested sampling loop
Z = zeros(maxits,1);
H = zeros(maxits,1);
logw = zeros(maxits,1);
Lw = zeros(maxits,1);
betas = zeros(maxits,numPCs);
Ra = zeros(maxits,1);
Dec = zeros(maxits,1);
Psi = zeros(maxits,1);
Tmp = zeros(maxits,1);
Ts = zeros(maxits,1);
Distance = zeros(maxits, 1);

%sampling frequency of waveforms
fs = 4096;

%time step to be used
sample_deltaT = 1/fs;





%load whitenoise.txt
% sets up the priors and initial chain values, will need to adjust these to
% include other catalogues. Can use findbetas.m to find max and mins.

maxbeta(1)=695; % maximum value for first coeffiecient
minbeta(1)=-32; % minimum value for first coeffiecient
betarange(1)=maxbeta(1)-minbeta(1); % range of values
betaprior(1)=-log(betarange(1)); % log of the first flat prior

maxbeta(2)=247;
minbeta(2)=-496;
betarange(2)=maxbeta(2)-minbeta(2);
betaprior(2)=-log(betarange(2));

maxbeta(3)=190;
minbeta(3)=-427;
betarange(3)=maxbeta(3)-minbeta(3);
betaprior(3)=-log(betarange(3));

maxbeta(4)=72;
minbeta(4)=-253;
betarange(4)=maxbeta(4)-minbeta(4);
betaprior(4)=-log(betarange(4));

maxbeta(5)=239;
minbeta(5)=-81;
betarange(5)=maxbeta(5)-minbeta(5);
betaprior(5)=-log(betarange(5));

maxbeta(6)=118;
minbeta(6)=-170;
betarange(6)=maxbeta(6)-minbeta(6);
betaprior(6)=-log(betarange(6));

maxbeta(7)=59;
minbeta(7)=-86;
betarange(7)=maxbeta(7)-minbeta(7);
betaprior(7)=-log(betarange(7));

maxbeta(8)=84.7;
minbeta(8)=-54;
betarange(8)=maxbeta(8)-minbeta(8);
betaprior(8)=-log(betarange(8));

maxbeta(9)=37;
minbeta(9)=-53;
betarange(9)=maxbeta(9)-minbeta(9);
betaprior(9)=-log(betarange(9));

maxbeta(10)=89;
minbeta(10)=-46;
betarange(10)=maxbeta(10)-minbeta(10);
betaprior(10)=-log(betarange(10));
if numPCs > 10;
    for Num=1:(numPCs-10);
        maxbeta(Num+10)=56;
        minbeta(Num+10)=-60;
        betarange(Num+10)=maxbeta(Num+10)-minbeta(Num+10);
        betaprior(Num+10)=-log(betarange(Num+10));
    end
end

if(doSky)
rg=0.1;
if ra>2*pi || ra<0
    fprintf(1,'Error: right ascension must be between 0 and 2pi\n');
else
    if ra+rg> 2*pi
        maxra=2*pi;
    else
    maxra=ra+rg;
    end
    if ra-rg<0
        minra=0;
    else
    minra=ra-rg;
    end
rarange=maxra-minra;
raprior=-log(rarange);
end

if dec>pi/2 || dec< -pi/2
     fprintf(1,'Error: declination must be between -pi/2 and pi/2\n');
else
     if dec+rg > pi/2 
        maxdec=2*pi;
     else
maxdec=dec+rg;
     end
     if dec-rg <-pi/2
         mindec=-pi/2;
     else
mindec=dec-rg;
     end
decrange=maxdec-mindec;
decprior=-log(decrange);
end

if psi > pi/4 || psi<-pi/4
    fprintf(1,'Error: polarisation angle must be between -pi/4 and pi/4\n');
else
    if psi+rg>pi/4
        maxpsi=pi/4;
    else
maxpsi=psi+rg;
    end
    if psi-rg<-pi/4
        minpsi=-pi/4;
    else
minpsi=psi-rg;
    end
psirange=maxpsi-minpsi;
psiprior=-log(psirange);
end
end
dt=0.1;
maxtmp=trigtime+0.5*dt;
mintmp=trigtime-0.5*dt;
tmprange=maxtmp-mintmp;
tmpprior=-log(tmprange);

%decrease numPCs if neccessary
% if numPCs > length(betaprior)
%     fprintf(1,'Error: numPCs may be at most 10\n');
%     numPCs = length(betaprior);
%     betas = zeros(maxits,numPCs);
%     fprintf(1,'numPCs changed to %i\n',numPCs);
% elseif numPCs > size(vectorPC,2)
%     fprintf(1,'Error: numPCs must be less than model catalogue size\n');
%     numPCs = size(vectorPC,2)-1;
%     betas = zeros(maxits,numPCs);
%     fprintf(1,'numPCs changed to %i\n',numPCs);
% end

% if(doTimeshift)
%     maxT=0.0005;%seconds
%     minT=-0.0005;%seconds
%     Trange=maxT-minT;%size of time-shift-bin
%     Tprior=-log(Trange);
% 
%     min_bin = -0.01;%seconds
%     max_bin = 0.01;%seconds
%     bin_sep = 0.0005;%seconds
%     bin_size = Trange;
%     mid_T0=[min_bin:bin_sep:max_bin];%positions of mid-points of bins
% else
    maxT=0;
    minT=0;
    Trange=maxT-minT;
    Tprior=-log(1);
%end
% prior for distance, assumes injected waveform is scaled to 10kpc and is
% scaled between 1kpc and 1000 kpc
if(doDistance)
    maxd=10/1;
    mind=10/1000;
    drange=maxd-mind;
    dprior=-log(drange);
else
    maxd=1;
    mind=1;
    drange=maxd-mind;
    dprior=-log(1);
end

%sumprior=sum(betaprior(1:numPCs)) ...
%           +tmpprior + Tprior + dprior
% set the number of active points in the Nested Sampling
numactive = 50;

% set the number of iterations in the MCMC for finding the next active
% point
nits = 50;

% load the set of eigenvectors for each catalogue
load(sprintf('data_%s_%d', model, fs));

for cnt3=1:detno;
    td(:,cnt3)=timedelay(ra,dec,trigtime,detector{cnt3});
end

len = length(resampledWF(:,1));
duration = len*sample_deltaT;
deltaF = 1/duration;
N=len;
t0=duration/len;
if ( mod(N,2)== 0 )
    numFreqs = N/2 - 1;
else
    numFreqs = (N-1)/2;
end

f = deltaF*[1:1:numFreqs]';
[vectorPC, values]=pc_evectors2(resampledWF,length(resampledWF(1,:)),1,1);
    %save data_Abd_time resampledWF
   % save values_Mur_time values
   
for cntdet=1:detno; 
    
for j=1:length(resampledWF(1,:));
    % scale and apply timeshift to each waveform in model
    modl(:,j)=fft(vectorPC(:,j))*(1/(fs));
    
    PC(:,j)=modl(1+1:numFreqs+1,j).*exp(-2*pi*1i*f*td(:,cntdet));
    
end

vectorsPC(cntdet).vectorPC=PC;
end


% This loads the waveform indicated in the input
% load the catalogues you want to compare
load(sprintf('data_%s_%d', catalogue, fs));

wave=resampledWF(:,wv);
Z=find(abs(wave)>0);
lennorm=Z(end)-Z(1)+1;
%wave=whitenoise;
% Sky position
%ra= 6;
%dec = 1;
%psi= 0;
%detector={'L1','H1','V1'};
%trigtime=944697615.0;
%Preparations FFTs


%Generate sigma according to a certain PSD file
noise_struct.deltaT = sample_deltaT;
noise_struct.data = zeros(length(wave),1);

% sig=0;
% for cntsigma=1:500;
% [noise_struct] = detectorNoise(noise_struct,noise_curve);
% sig1 = noise_struct.data(1:numFreqs+1).*conj(noise_struct.data(1:numFreqs+1));
% sig = sig+sig1;
% end
% sigma = sqrt(abs(sig) / (cntsigma));
%save sigma.txt sigma -ASCII
for cntdet=1:detno
[noise_struct,sigdet(:,cntdet)] = detectorNoise(noise_struct,noisecurve{cntdet});
end
%for z=1:detno;
 %   sigdet(:,z)=sigma;
    
    %sigdet(1:numFreqs,z)=sigi(:,z);%(1+1:numFreqs+1,z);
%end



   wave0=wave;
   for cntdet=1:detno;
   [Fp(:,cntdet), Fc] = det_response_wrapper(ra, dec,detector{cntdet},trigtime, psi);
  %Fp(:,cntdet)=1;

wave(:,cntdet)=(Fp(:,cntdet))*wave0;
%wave(:,cntdet)=wave0;
%SNR(cntdet)=computeSNR_colourednoisetest(wave(:,cntdet), sigdet(:,cntdet));
SNR(cntdet) = xoptimalsnr(wave(:,cntdet),t0,fs,sigdet(:,cntdet),0.3333,deltaF,f(1),f(end));
SNR(cntdet)=SNR(cntdet)^2;
end
NSNR=sqrt(sum(SNR));
% finds detector which largest SNR, this is what is used for scaling.
%Fpabs=abs(Fp);   
%mSNR=find(SNR==max(SNR));
%mFp=1;

% works out scale factor
if ~isempty(find(strcmpi(typeofscaling,{'SNR'})))
    
    scale_factor = (scaling/NSNR);
    effective_distance = 10/scale_factor;
    fprintf(1, 'Effective Distance: %f kpc\n', effective_distance);
    elseif ~isempty(find(strcmpi(typeofscaling,{'distance' 'dis' 'dist' 'd'})))
    scale_factor = 10/scaling;
    effective_distance = scaling;
    fprintf(1, 'Effective Distance: %f kpc\n', effective_distance);
    else
    effective_distance = 10;
    scale_factor = 1;
end
for cnt2=1:detno
  %  wave(:,cnt2)=0;
wave(:,cnt2)=scale_factor*wave(:,cnt2);
 %SNR(cnt2)=computeSNR_colourednoisetest(wave(:,cnt2), sigdet(:,cnt2));
 SNR(cnt2) = xoptimalsnr(wave(:,cnt2),t0,fs,sigdet(:,cnt2),0.3333,deltaF,f(1),f(end));
 SNR(cnt2)=SNR(cnt2)^2;
 fprintf(1, 'Detector %i: SNR = %f\n', cnt2, sqrt(SNR(cnt2)));
end 
NSNR=sqrt(sum(SNR));

currentfolder=cd;


reset(RandStream.getDefaultStream,seed);

for i=1:detno
    % Antenna response factors for already given sky position and detectors
    if(realnoise)
    % goes to directory containing noise file and loads frames
    if strcmp(detector(cntdet), 'L1');
 noisedir=sprintf('/home/jlogue/L1-FAKE-STRAIN/');
% noisedir=sprintf('/home/jlogue/Dropbox/S6noise/');
 cd(noisedir)
 [detnoise(:,2), detnoise(:,1), fsamp]=frgetvect('L-L1-871188665-64.gwf','L1:FAKE-STRAIN',0,64);
%[detnoise(:,2), detnoise(:,1), fsamp]=frgetvect('L-L1_LDAS_C02_L2-931035648-128.gwf','L1:LDAS-STRAIN',0,54);
    elseif strcmp(detector(cntdet), 'H1');
        %noisedir=sprintf('/home/jlogue/H1-FAKE-STRAIN/');
 %cd(noisedir)
 %[detnoise(:,2), detnoise(:,1), fsamp]=frgetvect('H-H1-871189238-64.gwf','H1:FAKE-STRAIN',0,64);
 load S6noise
    end
    
     freqratio=(fsamp(end)*2)/fs;
  freqratio=ceil(freqratio);  
   detnoise_resample=decimate(detnoise(:,2),freqratio); 
  % back to SMEE directory
 cd(currentfolder)
 %save S6noise detnoise fsamp
% detnoise_resample=sqrt(detnoise_resample);
% detnoise_resample=detnoise_resample*1e-6;
 noise1=detnoise_resample(1:length(wave));
 % take spectrogram of noise files and apply cutoff frequency
  noiseft=fft(noise1);
    %sigmaspec=spectrogram(Sigmaresampled,tvec,over,nfft,fs);
    noiseft=noiseft*(1/(fs));
    noisevec(:,i)=noiseft(1+1:numFreqs+1,i);
%noisevec(:,cntdet)=reshape((noisespec),length(S1(:,1))*length(S1(1,:)),1);

len=length(wave);
l=0;
sigdet1=0;
 for j=1:(length(detnoise_resample)/len);
      offsource=detnoise_resample(1+l:len*(j));
  sig=fft(offsource);
  sig=(abs(sig).^2).*(1/(fs*len));
  sig=sig(1+1:numFreqs+1,i);
  %Poffcut=(abs(Soff(cutoff:end-1,:))).^2*(1/(fs*sum(abs(hamming(length(S1(:,1)))).^2)));
  %Poffcut=(Poff(cutoff:end-1,:));%*sqrt(1/(fs*sum(hamming(length(F)).^2)));
  
   
   sigdet1=sigdet1+sig;
   l=l+len;
 end
 sigdet(:,i)=(sigdet1./j);
 save noisereal noisevec sigdet f
else
 
  noise_struct1.deltaT = sample_deltaT;
    noise_struct1.data = zeros(length(wave(:,i)),1);
    [noise_struct1] = detectorNoise(noise_struct1,noisecurve{i});
    noise = (noise_struct1.data);
    noisevec(:,i)=noise(1+1:numFreqs+1,:);

  end
    
    
    %td(:,)=timedelay(ra,dec,trigtime,detector{detno});
   
    %function to compute SNR of the waveform
    
   
    % inject waveform into two streams of gaussian noise and compute FFT
    % wave_ft_full(:,i) = noise;
    wave_fft(:,i) = fft(wave(:,i))*(1/(fs));
   
    
    wave_ft(:,i)=wave_fft(1+1:numFreqs+1,i);
    
    wave_ftplus(:,i)=wave_ft(:,i).*exp(-2*pi*1i*f*td(:,i));
    %res=2*(real(wave_ftplus(:,i)).*real(noisevec(:,i)) + imag(wave_ftplus(:,i)).*imag(noisevec(:,i)));
     %wave_ftplus(:,i)=(wave_ftplus(:,i) + noisevec(:,i));% - res;
     wave_ftplus(:,i)=(wave_ftplus(:,i) + noisevec(:,i));
     wave_ftplus(:,i)=wave_ftplus(:,i);
   
    % calculates the log of the evidence for noise only
    %evnoise(i) = 2*(1/len)*sum(-abs((wave_ftplus(1:end,i).^2))./(sigdet(1:end,i)));
   evnoise(i) = 2*deltaF*sum(-abs((wave_ftplus(1:end,i).^2))./(sigdet(1:end,i)));
   % evnoise(i) = -sum(abs(wave_ftplus(1:end,i).^2)./(2*sigdet(1:end,i)));
   save noisetest sigdet noisevec f wave_ft
    fprintf(1, 'Detector %i: log(Noise evidence) = %f\n', i, evnoise(i));
   
    % BEGIN save plots for testing purposes (to check against the Shoemaker aLIGO noise curve)
    % added by PK 12/13/11
    %[fpk, asdpk] = textread('ET_B.txt', '%f %f');
%     [fpk, asdpk] = textread('ZERO_DET_high_P.txt', '%f %f');
%     figure(42); clf;
%     noisetest = noise(1+1:numFreqs+1, i);
%     loglog(f, sqrt(sigdet));
%     hold on;
%     loglog(f, abs(noisetest), 'g');
%     loglog(fpk, asdpk, 'r');
%     hold off;
%     legend('sigma', 'noise', 'DCC');
%     saveplot('.', 'check_of_variable_noisepower', 'pdf');
%     xlim([100, 150]);
%     saveplot('.', 'check_of_variable_noisepower_zoom', 'pdf');
    % END save plots for testing purposes 

 
end

if scale_factor>1;
for cntdet=1:detno;
V_ft(cntdet).V_ft=(vectorsPC(cntdet).vectorPC) * 1e-22;%* scale_factor;
end
else
    for cntdet=1:detno;
    V_ft(cntdet).V_ft=(vectorsPC(cntdet).vectorPC) * 1e-22;
    end
end


%PCs in fourier domain
%V_ft_full = fft(V);
%V_ft = V_ft_full(1+1:numFreqs+1,:);
%V_ft=(V);
%V_ft=real(V_ft);
%wave_ft=real(wave_ft);
% create active points initially drawn from a uniform distribution for
% each value in beta
for cnt=1:numPCs
    activebeta(:,cnt) = rand(numactive,1)*(maxbeta(cnt)-minbeta(cnt)) + minbeta(cnt);
end
activetmp = rand(1,numactive)*(maxtmp-mintmp) + mintmp;
if(doSky)
activera = rand(1,numactive)*(maxra-minra) + minra;
activedec = rand(1,numactive)*(maxdec-mindec) + mindec;
activepsi = rand(1,numactive)*(maxpsi-minpsi) + minpsi;

end
actived = rand(1,numactive)*(maxd-mind) + mind;

% if(doTimeshift)
%     %find sum of likelihood for points in all the time shift bins, and then
%     %only use range of bins with highest summed likelihood
%     for k=1:length(mid_T0)
%         activeT_range(:,k) = rand(1,numactive)*(maxT-minT) - Trange/2 + mid_T0(k);
%         
%         like_sum = -1e37;
%         % calculate the likelihood*prior at these current active points
%         if(doSky)
%         likeactive = zeros(1,numactive) + sum(betaprior(1:numPCs)) ...
%             + raprior + decprior + psiprior + tmpprior + Tprior + dprior;
%         %coherent case: L is product over individual detector likelihoods
%         for j=1:numactive
%             for i=1:detno
%                 lp = like_gauss_fspace(wave_ft(:,i), sigdet(:,i), ...
%                     deltaF, len, f, activeT_range(j,k), @findy_Fptd, V_ft, ...
%                     activebeta(j,:), actived(j), numPCs, activera(j),activedec(j), ...
%                     activepsi(j),activetmp(j),detector{i});
%                 
%                 likeactive(j) = likeactive(j) + lp;% + sum(betaprior);
%                 
%             end
%             like_sum = logplus(like_sum,likeactive(j)-numactive);
%         end
%         else
%             likeactive = zeros(1,numactive) + sum(betaprior(1:numPCs)) ...
%             + Tprior + dprior;
%         %coherent case: L is product over individual detector likelihoods
%         for j=1:numactive
%             for i=1:detno
%                 lp = like_gauss_fspace(wave_ft(:,i), sigdet(:,i), ...
%                     deltaF, len, f, activeT_range(j,k), @findy_Fptd, V_ft, ...
%                     activebeta(j,:), actived(j), numPCs, ra,dec, ...
%                     psi,trigtime,detector{i});
%                 
%                 likeactive(j) = likeactive(j) + lp;% + sum(betaprior);
%                 
%             end
%             like_sum = logplus(like_sum,likeactive(j)-numactive);
%         end
%         end
%         like_avg(k) = like_sum;
%     
%     end
%     %pick the bins with highest sumed likelihood
%     like_avg_max = max(like_avg);
%     like_avg_min = min(like_avg);
%     idcs = find(like_avg_max-like_avg < 0.1*(like_avg_max-like_avg_min));
%     minT = mid_T0(idcs(1))-bin_size/2;
%     maxT = mid_T0(idcs(end))+bin_size/2;
%     Tprior = -log(maxT-minT);
% end
%time shift values for active points
activeT = rand(1,numactive)*(maxT-minT) + minT;

% calculate the likelihood*prior at these current active points
if(doSky)
likeactive = zeros(1,numactive) + sum(betaprior(1:numPCs))+ raprior + decprior ...
    +psiprior + tmpprior+ Tprior + dprior;
%coherent case: L is product over individual detector likelihoods
for j=1:numactive
    for i=1:detno
        lp = like_gauss_tspace(wave_ft(:,i), noisevec(:,i),sigdet(:,i), ...
            deltaF, len, f, activeT(j), activera(j),activedec(j),activepsi(j),...
            activetmp(j),detector{i},@findy_Fptd, V_ft(i).V_ft, activebeta(j,:), ...
             numPCs, actived(j));
        
        likeactive(j) = likeactive(j) + lp;% + sum(betaprior);
        
    end
end
else
    likeactive = zeros(1,numactive) + sum(betaprior(1:numPCs))+ ...
    Tprior + dprior+tmpprior;
%coherent case: L is product over individual detector likelihoods
for j=1:numactive
    for i=1:detno
        lp = like_gauss_tspace(wave_ft(:,i), noisevec(:,i), sigdet(:,i), ...
            deltaF, len, f, activeT(j), actived(j),ra,dec,psi,activetmp(j), ...
            detector{i}, @findy_Fptd, V_ft(i).V_ft, activebeta(j,:), ...
             numPCs,actived(j));%,ra,dec,psi,trigtime,detector{i});
        
        likeactive(j) = likeactive(j) + lp;% + sum(betaprior);
        
    end
end
end
Z(1) = -1e37;

j = 2;

logw(1) = log(1 - exp(-1/numactive));

% start nested sampling loop - use John Veitch's critereon of continuing until
% i <= numactive*infosafe*H, where we steal infosafe = 1.5 from John's code
infosafe = 1.5;
H(1) = 0;

if(doPlot)
    figure('OuterPosition',[70,100,1200,600]);
end

while j-2 <= numactive * infosafe * H(j-1)
    j
    if(doPlot)
        activebeta_avg = mean(activebeta);
        activeD_avg = mean(actived);
        %activeT_avg = mean(activeT);
        activetmp_avg = mean(activetmp);
        if(doSky);
        activera_avg = mean(activera);
        activedec_avg = mean(activedec);
        activepsi_avg = mean(activepsi);
        
       
        y_fft = findy_Fptd(V_ft(1).V_ft, activebeta_avg, activeD_avg, numPCs, activera_avg, ...
            activedec_avg,activepsi_avg,activetmp_avg,detector{i});%.*exp(-2*pi*1i*f.*activetmp_avg);
        
       % y = ifft([0; y_fft; 0; flipud(conj(y_fft))]);
       % y_sig_fft = wave0hplus+wave0hcross;
        else
         % y_fft = findy_Fptd(V_ft, activebeta_avg, activeD_avg, numPCs,ra, ...
         %   dec,psi,trigtime,detector{i}).*exp(-2*pi*1i*f.*trigtime);
        y_fft = findy_Fptd(V_ft(1).V_ft, activebeta_avg, numPCs);%.*exp(-2*pi*1i*f.*trigtime);
       % y = ifft([0; y_fft; 0; flipud(conj(y_fft))]);
        %y_sig_fft = fft(wave0hplus;
        end
      %same, in frequency domain, plus signal received by detector    
        subplot(1,3,1),loglog(f(30:6000),(wave_ftplus(30:6000,1)),...
            f(30:6000),abs(y_fft(30:6000)));
    
            min1 = min(activebeta(:,1));
            max1 = max(activebeta(:,1));
            min2 = min(activebeta(:,2));
            max2 = max(activebeta(:,2));
            min3 = min(activebeta(:,3));
            max3 = max(activebeta(:,3));
    
            % creates a plot of points for betas 1, 2 and 3, zooms in on final outcomes
            subplot(1,3,2),plot3(activebeta(:,1), activebeta(:,2), activebeta(:,3), '.');
            subplot(1,3,2),xlim([min1 max1]);
            xlabel('beta1');
            subplot(1,3,2),ylim([min2 max2]);
            ylabel('beta2');
            subplot(1,3,2),zlim([min3 max3]);
            zlabel('beta3');
            subplot(1,3,2),text(max1,max2,max3,['Iterations: ' num2str(j-2)]);
            
            if(doSky)
            ramin = min(activera);
            ramax = max(activera);
            decmin = min(activedec);
            decmax = max(activedec);
            psimin = min(activepsi);
            psimax = max(activepsi);
    
            % creates a plot of points for betas 1, 2 and 3, zooms in on final outcomes
            subplot(1,3,3),plot3(activera, activedec, activepsi, '.');
            subplot(1,3,3),xlim([ramin ramax]);
            xlabel('ra');
            subplot(1,3,3),ylim([decmin decmax]);
            ylabel('dec');
            subplot(1,3,3),zlim([psimin psimax]);
            zlabel('psi');
            subplot(1,3,3),text(ramax,decmax,psimax,['Iterations: ' num2str(j-2)]);
            end
        
        
        drawnow;
    end
    
    % find minimum of likelihoods
    [Lmin, idx] = min(likeactive);
    
    % get the log weight
    logWt = Lmin + logw(j-1);
    
    Z(j) = logplus(Z(j-1), logWt);
    
    % get values for using in posterior calculation
    Lw(j-1) = logWt;
    betas(j-1,:) = activebeta(idx,:);
    Ts(j-1) = activeT(idx);
    Distance(j-1) = actived(idx);
    Tmp(j-1)=activetmp(idx);
    if(doSky)
    Ra(j-1)= activera(idx);
    Dec(j-1)=activedec(idx);
    Psi(j-1)=activepsi(idx);
    
    end
    % calculate the information H
    H(j) = exp(logWt - Z(j))*Lmin + exp(Z(j-1) - Z(j)) *...
        (H(j-1) + Z(j-1)) - Z(j);
    
    
    Activebeta(:,1:numPCs)=activebeta;
    Activebeta(:,numPCs+1)=activetmp;
    if(doSky);
    Activebeta(:,numPCs+2)=activera;
    Activebeta(:,numPCs+3)=activedec;
    Activebeta(:,numPCs+4)=activepsi;
    
    end
    
    if(doSky)
%      if (doDistance && doTimeshift)
%         Activebeta(:,numPCs+5)=actived;
%         Activebeta(:,numPCs+6)=activeT;
    if (doDistance)
        Activebeta(:,numPCs+5)=actived;
%     elseif (doTimeshift)
%         Activebeta(:,numPCs+5)=activeT;
    end   
    else
%     if (doDistance && doTimeshift)
%         Activebeta(:,numPCs+2)=actived;
%         Activebeta(:,numPCs+3)=activeT;
    if (doDistance)
        Activebeta(:,numPCs+2)=actived;
%     elseif (doTimeshift)
%         Activebeta(:,numPCs+2)=activeT;
    end
    end
    % update the log width
    logw(j) = logw(j-1) - 1/numactive;
    
    % will need to change 2nd argument to number of PC's used
    if(doSky)
    if mod(j-2, numPCs + 4 + doDistance + doTimeshift)== 0
        cholmat = cholcov(cov(Activebeta));
    end
    else
        if mod(j-2, numPCs +1+ doDistance + doTimeshift)== 0
        cholmat = cholcov(cov(Activebeta));
        end
    end
    good = 0;
    
    % incase no useable point is returned in the first MCMC keep repeating
    % until one is
    while good == 0
        % from the active points randomly pick a starting point for the chain
        randval = ceil(rand(1)*numactive);
        
        betachain = zeros(nits+1, numPCs);
        Tchain = zeros(nits+1, 1);
        dchain = zeros(nits+1, 1);
        tmpchain = zeros(nits+1, 1);
        if(doSky)
        rachain = zeros(nits+1, 1);
        decchain = zeros(nits+1, 1);
        psichain = zeros(nits+1, 1);
        
        end
        
        betachain(1,:) = activebeta(randval,:);
        Tchain(1) = activeT(randval);
        dchain(1) = actived(randval);
        tmpchain(1) = activetmp(randval);
        if(doSky)
        rachain(1) = activera(randval);
        decchain(1) = activedec(randval);
        psichain(1) = activepsi(randval);
        
        end
        
        Lcur = likeactive(randval);
        
        acc = 0; % count accepted points
        
        % start MCMC chain
        for k=1:nits
            % generate new position from proposal
            if(doSky)
            gasvals = randn(numPCs + 4 + doTimeshift + doDistance,1);
            else
                gasvals = randn(numPCs +1+ doTimeshift + doDistance,1);
            end
            newvals = cholmat*gasvals;
            
            betanew = betachain(k,:) + newvals(1:numPCs)';
            tmpnew = tmpchain(k) + newvals(numPCs+1);
            if(doSky)
            ranew = rachain(k) + newvals(numPCs+2);
            decnew = decchain(k) + newvals(numPCs+3);
            psinew = psichain(k) + newvals(numPCs+4);
            
            end
            
            
%             if(doTimeshift)
%                 Tnew = Tchain(k) + newvals(end);
%             else
                Tnew = Tchain(k);
            %end
            if(doDistance)
                dnew = dchain(k) + newvals(end-doTimeshift);
            else
                dnew = dchain(k);
            end
            
            if(doSky)
            % if new point is not within prior range then reject point
            if any((betanew < minbeta(1:numPCs)) | (betanew > maxbeta(1:numPCs))) || ...
                    ranew < minra || ranew > maxra || ...
                    decnew < mindec || decnew > maxdec || ...
                    psinew < minpsi || psinew > maxpsi || ...
                    tmpnew < mintmp || tmpnew > maxtmp || ...
                    dnew < mind || dnew > maxd || ...
                    Tnew < minT || Tnew > maxT
                
                betachain(k+1,:) = betachain(k,:);
                rachain(k+1) = rachain(k);
                decchain(k+1) = decchain(k);
                psichain(k+1) = psichain(k);
                tmpchain(k+1) = tmpchain(k);
                Tchain(k+1) = Tchain(k);
                dchain(k+1) = dchain(k);
                continue;
            end
            else
                if any((betanew < minbeta(1:numPCs)) | (betanew > maxbeta(1:numPCs))) || ...
                        tmpnew < mintmp || tmpnew > maxtmp || ...  
                    dnew < mind || dnew > maxd || ...
                    Tnew < minT || Tnew > maxT
                
                betachain(k+1,:) = betachain(k,:);
                tmpchain(k+1) = tmpchain(k);
                Tchain(k+1) = Tchain(k);
                dchain(k+1) = dchain(k);
                continue;
                end
            end
            % get likelihood for new position
            %coherent case: L is product over individual detector likelihoods
            if(doSky)
            Lnew = sum(betaprior(1:numPCs)) + raprior + decprior + psiprior + tmpprior + Tprior + dprior;
            for i=1:detno
                lp = like_gauss_tspace(wave_ft(:,i), noisevec(:,i), sigdet(:,i), ...
                    deltaF, len, f, Tnew,dnew, ranew,decnew,psinew,tmpnew,detector{i}, ...
                    @findy_Fptd, V_ft(i).V_ft, betanew,numPCs,dnew);
                
                Lnew = Lnew + lp;% + sum(betaprior) ;
            end
            else
                Lnew = sum(betaprior(1:numPCs))  + Tprior + dprior+tmpprior;
            for i=1:detno
                lp = like_gauss_tspace(wave_ft(:,i), noisevec(:,i),sigdet(:,i), ...
                    deltaF, len, f, Tnew,dnew, ra,dec,psi,tmpnew,detector{i},...
                    @findy_Fptd, V_ft(i).V_ft, betanew, numPCs,dnew);
                
                Lnew = Lnew + lp;% + sum(betaprior) ;
            end
            end
            % check whether to accept or reject the new point
            Lrat = Lnew - Lcur;
            
            if Lrat - log(rand) >= 0 && Lnew > Lmin
                
                betachain(k+1,:) = betanew;
                 tmpchain(k+1) = tmpnew;
                if(doSky)
                rachain(k+1) = ranew;
                decchain(k+1) = decnew;
                psichain(k+1) = psinew;
               
                end
                Tchain(k+1) = Tnew;
                dchain(k+1) = dnew;
                Lcur = Lnew;
                acc = acc + 1;
            else
                
                betachain(k+1,:) = betachain(k,:);
                 tmpchain(k+1) = tmpchain(k);
                if(doSky)
                rachain(k+1) = rachain(k);
                decchain(k+1) = decchain(k);
                psichain(k+1) = psichain(k);
               
                end
                Tchain(k+1) = Tchain(k);
                dchain(k+1) = dchain(k);
            end
        end
        
        if acc > 0
            good = 1;
        end
    end
    % substitute the final values of the MCMC chain into the position of
    % Lmin
    activebeta(idx,:) = betachain(end,:);
    activetmp(idx) = tmpchain(end);
    if(doSky)
    activera(idx) = rachain(end);
    activedec(idx) = decchain(end);
    activepsi(idx) = psichain(end);
    
    end
    activeT(idx) = Tchain(end);
    actived(idx) = dchain(end);
    
    likeactive(idx) = Lcur;
    
    j=j+1;
end

% we're no longer reducing the prior distribution, so weights stay the same
% as (1/N)*X_j
logwend = logw(j-1) -logw(1) - log(numactive);

% add the remaining points
for k=1:numactive
    logw(j+k-1) = logwend;
    Z(j+k-1) = logplus(Z(j+k-2), likeactive(k) + logw(j+k-1));
    Lw(k+j-2) = likeactive(k) + logw(j+k-1);
    betas(k+j-2,:) = activebeta(k,:);
    Tmp(k+j-2) = activetmp(k);
    if(doSky)
    Ra(k+j-2) = activera(k);
    Dec(k+j-2) = activedec(k);
    Psi(k+j-2) = activepsi(k);
    
    end
    Ts(k+j-2) = activeT(k);
    Distance(k+j-2) = actived(k);
end

%reduce size of variables to be exported
Z = Z(1:j-1+numactive);
Lw = Lw(1:j-2+numactive);
betas = betas(1:j-2+numactive,:);
Tmp= Tmp (1:j-2+numactive);
if(doSky)
Ra = Ra(1:j-2+numactive);
Dec = Dec(1:j-2+numactive);
Psi = Psi(1:j-2+numactive);

end
Ts = Ts(1:j-2+numactive);
Z_end= Z(j-1+numactive);
Bayes=Z(j-1+numactive)-sum(evnoise);
distance= Distance(1:j-2+numactive);


rnums = rand(1,length(Lw));

wt = logw(1:length(Lw)) + Lw;
maxwt = max(wt);
idx = find(wt' > maxwt+log(rnums));

postbetas = betas(idx,:);
postTmp = Tmp(idx,:);
if(doSky)
postra = Ra(idx,:);
postdec = Dec(idx,:);
postpsi = Psi(idx,:);

end
postT= Ts(idx,:);
postdis= distance(idx,:);
HOME = getenv('SMEE_HOME');
resultsdir=sprintf('/Users/jlogue/Dropbox/jlogue/Nested_Supernova/Results/%s/', run_name);
%resultsdir=sprintf('%s/jlogue/Nested_Supernova/Results/%s/', HOME, run_name);
%resultsdir=run_name;
%mkdir(resultsdir);
% save a simple txt file with a line of output
outFile = sprintf('%s/smee_results.txt', resultsdir);
fid = fopen(outFile, 'a');
fprintf(fid, '%1.4e %8.4f %1.4e\n ', evnoise, Bayes, SNR);
fclose(fid);

%print evidence for model
fprintf(1, 'Network: log(%s Evidence) = %f\n', model, Z_end);
fprintf(1, 'log(nested sampling Bayes factor vs Noise) = %f\n', Bayes);

%print extra output data
fprintf(1, 'No. of Iterations: %i\n', j);
fprintf(1,'H = %f\n', H(j-1));
for cnt=1:numPCs
    B(cnt)=mean(postbetas(:,cnt));
    fprintf(1,'<B_%i> = %f\n',cnt,mean(postbetas(:,cnt)));
end
fprintf(1,'<trigtime> = %f\n',mean(postTmp));
if(doSky)
fprintf(1,'<ra> = %f\n',mean(postra));
fprintf(1,'<dec> = %f\n',mean(postdec));
fprintf(1,'<psi> = %f\n',mean(postpsi));

end
fprintf(1,'<T> = %f\n',mean(postT));
fprintf(1,'<D> = %f\n',10/mean(postdis));
lp_end = like_gauss_tspace(wave_ft(:,1), noisevec(:,1), sigdet(:,1), ...
                    deltaF, len, f,mean(postT),mean(postdis), ra,dec,psi,mean(postTmp),...
                    detector{1}, @findy_Fptd, V_ft(1).V_ft, B, ...
                     numPCs,mean(postdis));
lp_end=lp_end+sum(betaprior(1:numPCs)) + Tprior + dprior + tmpprior;
Dtheta=-2*lp_end;
D=-2*mean(Lw);
DIC=2*D-Dtheta;

if(doSky)
posterior_params_savefile = ['smee_output_' catalogue num2str(wv) '_model' model '_PCs' num2str(numPCs)...
    '_detno' num2str(detno) '_' typeofscaling strrep(num2str(scaling), '.', 'p') '_seed' num2str(seed)];
save([resultsdir posterior_params_savefile],'catalogue','wv','model','betas','detno',...
    'Ts','seed','distance','Lw', 'evnoise','Z_end','Bayes','NSNR','effective_distance', 'numPCs', ...
    'postbetas','postra', 'postdec', 'postpsi', 'postTmp','postT','postdis','DIC','postdis');
else
    posterior_params_savefile = ['smee_output_' catalogue num2str(wv) '_model' model '_PCs' num2str(numPCs)...
    '_detno' num2str(detno) '_' typeofscaling strrep(num2str(scaling), '.', 'p') '_seed' num2str(seed)];
save([resultsdir posterior_params_savefile],'catalogue','wv','model','betas','detno',...
    'Ts','seed','distance','Lw', 'evnoise','Z_end','Bayes','NSNR','effective_distance', 'numPCs', ...
    'postbetas','postT','postdis','postTmp','Z','likeactive','logw','DIC','postdis');
end

% clear H Lcur betas Lmin Lnew Lrat acc activebeta betachain cholmat betanew V fs...
%     gasvals good idx infosafe likeactive logWt logdbeta Lw logwend logw maxwt...
%     mlog2 newvals randval rnums wt Z lp l j k Activebeta ActiveT activeT Ts Tchain Tnew model ...
%     activera activedec activera activetmp actived rachain decchain psichain tmpchain ...
%     ranew decnew psinew tmpnew dnew 
clear all
toc
%exit
